0 : All API elements, i.e.:
    - modules
    - module types
    - functions & values
    - types
    are present if and only if are needed for implementing Coq plugins.

1 : Individual API elements are not aliased.

    That is, if API provides some module/type/value,
    it provides it once and only once.

    MOTIVATION:

    Ocaml programming language enables us to define aliases of:
    - modules
    - types
    - values
    That is, it enables us to give multiple names to one and the same concept.

    Canonic code-bases, e.g.:
    - Ocaml standard library
    - Ocaml Batteries
    - Core
    rarely use this mechanism.

    It is curious that Coq codebase uses this mechanism so heavily
    which makes one wonder:
    - What is the point of all those aliases?
    - Is this mechanism used as a workaround for some problem? Which one?
    - Cannot the problem itself be solved, rather than working around it?

    Until we find the answer to those questions (for each and every alias)
    we will continue to regard aliases as noise and thus remove/deprecate them.

    CONSEQUENCE

    "Constr" module does not appear in the API because whatever it provides
    is also provided by "Term" (which is already present in the API).

2 : Each API element is an alias of some original concept that exists in the Coq codebase.
    In the other words, no API element is an alias of an alias.

    MOTIVATION

    If we want to maintain property #1, then whenever we are about to add something to the API,
    we need to decide whether the same concept is or is not already present in the API (under some name).

    In general, this decision procedure has linear complexity (wrt. the size of the API).
    If we stick to property #2, this decision procedure has constant complexity (wrt. the size of the API);

    Property thus #2 makes it feasible to maintain property #1.

    NOTE

    In case of types which are tuples and products, we are still in trouble.
    In order to be sure that we are not adding another alias for an existing original type
    that is already present in the API, we still have to check the whole API/API.mli file.

    EXCEPTIONS
    - In concord with the note attached to "Proof_type.tactic",
      instead of exposing "Proof_type.tactic", we expose "Tacmach.tactic".
