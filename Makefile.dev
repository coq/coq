##########################################################################
##         #   The Coq Proof Assistant / The Coq Development Team       ##
##  v      #   INRIA, CNRS and contributors - Copyright 1999-2019       ##
## <O___,, #       (see CREDITS file for the list of authors)           ##
##   \VV/  ###############################################################
##    //   #    This file is distributed under the terms of the         ##
##         #     GNU Lesser General Public License Version 2.1          ##
##         #     (see LICENSE file for the text of the license)         ##
##########################################################################

# Extra targets for developers :
# debug printers, revision, partial targets ...

#########################
# Debug printers in dev/
#########################

.PHONY: devel printers

DEBUGPRINTERS:=dev/top_printers.cmo dev/vm_printers.cmo

devel: printers
printers: $(CORECMA) $(DEBUGPRINTERS)

############
# revision
############

# display the revision number when compiling a checked out source tree

revision:
	$(SHOW)'CHECK revision'
	$(HIDE)rm -f revision.new
	$(HIDE)set -e; \
	./dev/tools/make_git_revision.sh > revision.new
	$(HIDE)set -e; \
	if test -e revision.new; then \
          if test -e revision; then \
	    if test "`cat revision`" = "`cat revision.new`" ; then \
	       rm -f revision.new; \
            else \
               mv -f revision.new revision; \
            fi; \
          else \
            mv -f revision.new revision; \
          fi \
	fi

.PHONY: revision

###################
# Partial builds
###################

# The following partial targets are normally not necessary
# for a complete build of coq, see instead 'make world' for that.
# But these partial targets could be quite handy for quick builds
# of specific components of Coq.

###############################
### 1) general-purpose targets
###############################

coqlight: stdlib-light tools coqbinaries

states: stdlib/theories/Init/Prelude.$(VO)

miniopt: $(COQTOPEXE) pluginsopt
minibyte: $(COQTOPBYTE) pluginsbyte

pluginsopt: $(PLUGINSOPT)
pluginsbyte: $(PLUGINS)

# This should build all the ocaml code but not (most of) the .v files
coqocaml: tools coqbinaries $(PLUGINSCMO:.cmo=$(DYNOBJ)) coqide printers bin/votour

.PHONY: coqlight states miniopt minibyte pluginsopt pluginsbyte coqocaml

##########################
### 2) core ML components
##########################

lib: lib/clib.cma lib/lib.cma
kernel: kernel/kernel.cma
byterun: $(BYTERUN)
library: library/library.cma
engine: engine/engine.cma
proofs: proofs/proofs.cma
tactics: tactics/tactics.cma
interp: interp/interp.cma
parsing: parsing/parsing.cma
pretyping: pretyping/pretyping.cma
stm: stm/stm.cma
toplevel: toplevel/toplevel.cma

.PHONY: lib kernel byterun library proofs tactics interp parsing pretyping
.PHONY: engine stm toplevel

######################
### 3) theories files
######################

init: $(filter stdlib/theories/Init/%, $(STDLIBVO))
logic: $(filter stdlib/theories/Logic/%, $(STDLIBVO))
arith: $(filter stdlib/theories/Arith/%, $(STDLIBVO))
bool: $(filter stdlib/theories/Bool/%, $(STDLIBVO))
parith: $(filter stdlib/theories/PArith/%, $(STDLIBVO))
narith: $(filter stdlib/theories/NArith/%, $(STDLIBVO))
zarith: $(filter stdlib/theories/ZArith/%, $(STDLIBVO))
qarith: $(filter stdlib/theories/QArith/%, $(STDLIBVO))
lists: $(filter stdlib/theories/Lists/%, $(STDLIBVO))
strings: $(filter stdlib/theories/Strings/%, $(STDLIBVO))
sets: $(filter stdlib/theories/Sets/%, $(STDLIBVO))
fsets: $(filter stdlib/theories/FSets/%, $(STDLIBVO))
relations: $(filter stdlib/theories/Relations/%, $(STDLIBVO))
wellfounded: $(filter stdlib/theories/Wellfounded/%, $(STDLIBVO))
reals: $(filter stdlib/theories/Reals/%, $(STDLIBVO))
setoids: $(filter stdlib/theories/Setoids/%, $(STDLIBVO))
sorting: $(filter stdlib/theories/Sorting/%, $(STDLIBVO))
numbers: $(filter stdlib/theories/Numbers/%, $(STDLIBVO))
unicode: $(filter stdlib/theories/Unicode/%, $(STDLIBVO))
classes: $(filter stdlib/theories/Classes/%, $(STDLIBVO))
program: $(filter stdlib/theories/Program/%, $(STDLIBVO))
structures: $(filter stdlib/theories/Structures/%, $(STDLIBVO))
vectors: $(filter stdlib/theories/Vectors/%, $(STDLIBVO))
msets: $(filter stdlib/theories/MSets/%, $(STDLIBVO))
compat: $(filter stdlib/theories/Compat/%, $(STDLIBVO))

stdlib-light: $(STDLIBLIGHTVO)

noreal: unicode logic arith bool zarith qarith lists sets fsets \
	relations wellfounded setoids sorting

.PHONY: init stdlib-light noreal
.PHONY: logic arith bool narith zarith qarith lists strings sets
.PHONY: fsets relations wellfounded reals setoids sorting numbers
.PHONY: msets mmaps compat parith classes program unicode structures vectors

################
### 4) plugins
################

OMEGAVO:=$(filter stdlib/plugins/omega/%, $(STDLIBVO))
MICROMEGAVO:=$(filter stdlib/plugins/micromega/%, $(STDLIBVO))
RINGVO:=$(filter stdlib/plugins/setoid_ring/%, $(STDLIBVO))
NSATZVO:=$(filter stdlib/plugins/nsatz/%, $(STDLIBVO))
FUNINDVO:=$(filter stdlib/plugins/funind/%, $(STDLIBVO))
BTAUTOVO:=$(filter stdlib/plugins/btauto/%, $(STDLIBVO))
RTAUTOVO:=$(filter stdlib/plugins/rtauto/%, $(STDLIBVO))
EXTRACTIONVO:=$(filter stdlib/plugins/extraction/%, $(STDLIBVO))
CCVO:=
DERIVEVO:=$(filter stdlib/plugins/derive/%, $(STDLIBVO))
LTACVO:=$(filter stdlib/plugins/ltac/%, $(STDLIBVO))

omega: $(OMEGAVO) $(OMEGACMO)
micromega: $(MICROMEGAVO) $(MICROMEGACMO) $(CSDPCERT)
setoid_ring: $(RINGVO) $(RINGCMO)
nsatz: $(NSATZVO) $(NSATZCMO)
extraction: $(EXTRACTIONCMO) $(EXTRACTIONVO)
funind: $(FUNINDCMO) $(FUNINDVO)
cc: $(CCVO) $(CCCMO)
rtauto: $(RTAUTOVO) $(RTAUTOCMO)
btauto: $(BTAUTOVO) $(BTAUTOCMO)
ltac: $(LTACVO) $(LTACCMO)

.PHONY: omega micromega setoid_ring nsatz extraction
.PHONY: funind cc rtauto btauto ltac

# For emacs:
# Local Variables:
# mode: makefile
# End:
