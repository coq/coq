File "./output/SchemeNames.v", line 15, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Prop" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Prop"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 16, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Set" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Set"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 17, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{SchemeNames.23}" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{SchemeNames.23}"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 18, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{α3 | SchemeNames.24}"
while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{α3 | SchemeNames.24}"
because strict proofs can be eliminated only to build strict proofs.
fooSProp_inds :
forall P : fooSProp -> SProp, P aSP -> P bSP -> forall f1 : fooSProp, P f1

fooSProp_inds is not universe polymorphic
Arguments fooSProp_inds P%_function_scope f f0 f1
fooSProp_inds is transparent
Expands to: Constant SchemeNames.fooSProp_inds
File "./output/SchemeNames.v", line 25, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Prop" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Prop"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 26, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Set" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Set"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 27, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{SchemeNames.25}" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{SchemeNames.25}"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 28, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{α4 | SchemeNames.26}"
while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{α4 | SchemeNames.26}"
because strict proofs can be eliminated only to build strict proofs.
fooSProp_inds_nodep : forall P : SProp, P -> P -> fooSProp -> P

fooSProp_inds_nodep is not universe polymorphic
Arguments fooSProp_inds_nodep P%_type_scope f f0 f1
fooSProp_inds_nodep is transparent
Expands to: Constant SchemeNames.fooSProp_inds_nodep
File "./output/SchemeNames.v", line 35, characters 2-49:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Prop" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Prop"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 36, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Set" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Set"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 37, characters 2-49:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{SchemeNames.27}" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{SchemeNames.27}"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 38, characters 2-49:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{α5 | SchemeNames.28}"
while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{α5 | SchemeNames.28}"
because strict proofs can be eliminated only to build strict proofs.
fooSProp_cases :
forall P : fooSProp -> SProp, P aSP -> P bSP -> forall f1 : fooSProp, P f1

fooSProp_cases is not universe polymorphic
Arguments fooSProp_cases P%_function_scope f f0 f1
fooSProp_cases is transparent
Expands to: Constant SchemeNames.fooSProp_cases
File "./output/SchemeNames.v", line 45, characters 2-42:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Prop" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Prop"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 46, characters 2-41:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Set" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Set"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 47, characters 2-42:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{SchemeNames.29}" while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{SchemeNames.29}"
because strict proofs can be eliminated only to build strict proofs.
File "./output/SchemeNames.v", line 48, characters 2-42:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooSProp@{}":
the return type has sort "Type@{α6 | SchemeNames.30}"
while it should be SProp.
Elimination of an inductive object of sort SProp
is not allowed on a predicate in sort "Type@{α6 | SchemeNames.30}"
because strict proofs can be eliminated only to build strict proofs.
fooSProp_cases_nodep : forall P : SProp, P -> P -> fooSProp -> P

fooSProp_cases_nodep is not universe polymorphic
Arguments fooSProp_cases_nodep P%_type_scope f f0 f1
fooSProp_cases_nodep is transparent
Expands to: Constant SchemeNames.fooSProp_cases_nodep
File "./output/SchemeNames.v", line 54, characters 2-36:
The command has indeed failed with message:
Cannot extract computational content from proposition 
"fooSProp".
File "./output/SchemeNames.v", line 66, characters 2-45:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Set" while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Set"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 67, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{SchemeNames.33}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{SchemeNames.33}"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 68, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{α9 | SchemeNames.34}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{α9 | SchemeNames.34}"
because proofs can be eliminated only to build proofs.
fooProp_inds_dep :
forall P : fooProp -> SProp, P aP -> P bP -> forall f1 : fooProp, P f1

fooProp_inds_dep is not universe polymorphic
Arguments fooProp_inds_dep P%_function_scope f f0 f1
fooProp_inds_dep is transparent
Expands to: Constant SchemeNames.fooProp_inds_dep
fooProp_ind_dep :
forall P : fooProp -> Prop, P aP -> P bP -> forall f1 : fooProp, P f1

fooProp_ind_dep is not universe polymorphic
Arguments fooProp_ind_dep P%_function_scope f f0 f1
fooProp_ind_dep is transparent
Expands to: Constant SchemeNames.fooProp_ind_dep
File "./output/SchemeNames.v", line 77, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Set" while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Set"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 78, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{SchemeNames.35}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{SchemeNames.35}"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 79, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{α10 | SchemeNames.36}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{α10 | SchemeNames.36}"
because proofs can be eliminated only to build proofs.
fooProp_inds : forall P : SProp, P -> P -> fooProp -> P

fooProp_inds is not universe polymorphic
Arguments fooProp_inds P%_type_scope f f0 f1
fooProp_inds is transparent
Expands to: Constant SchemeNames.fooProp_inds
fooProp_ind : forall P : Prop, P -> P -> fooProp -> P

fooProp_ind is not universe polymorphic
Arguments fooProp_ind P%_type_scope f f0 f1
fooProp_ind is transparent
Expands to: Constant SchemeNames.fooProp_ind
File "./output/SchemeNames.v", line 88, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Set" while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Set"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 89, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{SchemeNames.37}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{SchemeNames.37}"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 90, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{α11 | SchemeNames.38}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{α11 | SchemeNames.38}"
because proofs can be eliminated only to build proofs.
fooProp_cases_dep :
forall P : fooProp -> SProp, P aP -> P bP -> forall f1 : fooProp, P f1

fooProp_cases_dep is not universe polymorphic
Arguments fooProp_cases_dep P%_function_scope f f0 f1
fooProp_cases_dep is transparent
Expands to: Constant SchemeNames.fooProp_cases_dep
fooProp_case_dep :
forall P : fooProp -> Prop, P aP -> P bP -> forall f1 : fooProp, P f1

fooProp_case_dep is not universe polymorphic
Arguments fooProp_case_dep P%_function_scope f f0 f1
fooProp_case_dep is transparent
Expands to: Constant SchemeNames.fooProp_case_dep
File "./output/SchemeNames.v", line 99, characters 2-40:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Set" while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Set"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 100, characters 2-41:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{SchemeNames.39}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{SchemeNames.39}"
because proofs can be eliminated only to build proofs.
File "./output/SchemeNames.v", line 101, characters 2-41:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooProp@{}":
the return type has sort "Type@{α12 | SchemeNames.40}"
while it should be SProp or Prop.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort "Type@{α12 | SchemeNames.40}"
because proofs can be eliminated only to build proofs.
fooProp_cases : forall P : SProp, P -> P -> fooProp -> P

fooProp_cases is not universe polymorphic
Arguments fooProp_cases P%_type_scope f f0 f1
fooProp_cases is transparent
Expands to: Constant SchemeNames.fooProp_cases
fooProp_case : forall P : Prop, P -> P -> fooProp -> P

fooProp_case is not universe polymorphic
Arguments fooProp_case P%_type_scope f f0 f1
fooProp_case is transparent
Expands to: Constant SchemeNames.fooProp_case
File "./output/SchemeNames.v", line 108, characters 2-35:
The command has indeed failed with message:
Cannot extract computational content from proposition 
"fooProp".
fooSet_inds :
forall P : fooSet -> SProp, P aS -> P bS -> forall f1 : fooSet, P f1

fooSet_inds is not universe polymorphic
Arguments fooSet_inds P%_function_scope f f0 f1
fooSet_inds is transparent
Expands to: Constant SchemeNames.fooSet_inds
fooSet_ind :
forall P : fooSet -> Prop, P aS -> P bS -> forall f1 : fooSet, P f1

fooSet_ind is not universe polymorphic
Arguments fooSet_ind P%_function_scope f f0 f1
fooSet_ind is transparent
Expands to: Constant SchemeNames.fooSet_ind
fooSet_rec :
forall P : fooSet -> Set, P aS -> P bS -> forall f1 : fooSet, P f1

fooSet_rec is not universe polymorphic
Arguments fooSet_rec P%_function_scope f f0 f1
fooSet_rec is transparent
Expands to: Constant SchemeNames.fooSet_rec
fooSet_rect :
forall P : fooSet -> Type@{fooSet_rect.u0},
P aS -> P bS -> forall f1 : fooSet, P f1

fooSet_rect is not universe polymorphic
Arguments fooSet_rect P%_function_scope f f0 f1
fooSet_rect is transparent
Expands to: Constant SchemeNames.fooSet_rect
fooSet_elim@{q | u} :
forall P : fooSet -> Type@{q | u}, P aS -> P bS -> forall f1 : fooSet, P f1
(* q | u |=  *)

fooSet_elim is universe polymorphic
Arguments fooSet_elim P%function_scope f f0 f1
fooSet_elim is transparent
Expands to: Constant SchemeNames.fooSet_elim
fooSet_inds_nodep : forall P : SProp, P -> P -> fooSet -> P

fooSet_inds_nodep is not universe polymorphic
Arguments fooSet_inds_nodep P%_type_scope f f0 f1
fooSet_inds_nodep is transparent
Expands to: Constant SchemeNames.fooSet_inds_nodep
fooSet_ind_nodep : forall P : Prop, P -> P -> fooSet -> P

fooSet_ind_nodep is not universe polymorphic
Arguments fooSet_ind_nodep P%_type_scope f f0 f1
fooSet_ind_nodep is transparent
Expands to: Constant SchemeNames.fooSet_ind_nodep
fooSet_rec_nodep : forall P : Set, P -> P -> fooSet -> P

fooSet_rec_nodep is not universe polymorphic
Arguments fooSet_rec_nodep P%_type_scope f f0 f1
fooSet_rec_nodep is transparent
Expands to: Constant SchemeNames.fooSet_rec_nodep
fooSet_rect_nodep :
forall P : Type@{fooSet_rect_nodep.u0}, P -> P -> fooSet -> P

fooSet_rect_nodep is not universe polymorphic
Arguments fooSet_rect_nodep P%_type_scope f f0 f1
fooSet_rect_nodep is transparent
Expands to: Constant SchemeNames.fooSet_rect_nodep
fooSet_elim_nodep@{q | u} :
forall P : Type@{q | u}, P -> P -> fooSet -> P
(* q | u |=  *)

fooSet_elim_nodep is universe polymorphic
Arguments fooSet_elim_nodep P%type_scope f f0 f1
fooSet_elim_nodep is transparent
Expands to: Constant SchemeNames.fooSet_elim_nodep
fooSet_cases :
forall P : fooSet -> SProp, P aS -> P bS -> forall f1 : fooSet, P f1

fooSet_cases is not universe polymorphic
Arguments fooSet_cases P%_function_scope f f0 f1
fooSet_cases is transparent
Expands to: Constant SchemeNames.fooSet_cases
fooSet_case :
forall P : fooSet -> Prop, P aS -> P bS -> forall f1 : fooSet, P f1

fooSet_case is not universe polymorphic
Arguments fooSet_case P%_function_scope f f0 f1
fooSet_case is transparent
Expands to: Constant SchemeNames.fooSet_case
fooSet'_case :
forall P : fooSet' -> Set, P aS' -> P bS' -> forall f1 : fooSet', P f1

fooSet'_case is not universe polymorphic
Arguments fooSet'_case P%_function_scope f f0 f1
fooSet'_case is transparent
Expands to: Constant SchemeNames.fooSet'_case
fooSet'_caset :
forall P : fooSet' -> Type@{fooSet'_caset.u0},
P aS' -> P bS' -> forall f1 : fooSet', P f1

fooSet'_caset is not universe polymorphic
Arguments fooSet'_caset P%_function_scope f f0 f1
fooSet'_caset is transparent
Expands to: Constant SchemeNames.fooSet'_caset
fooSet'_casep@{q | u} :
forall P : fooSet' -> Type@{q | u},
P aS' -> P bS' -> forall f1 : fooSet', P f1
(* q | u |=  *)

fooSet'_casep is universe polymorphic
Arguments fooSet'_casep P%function_scope f f0 f1
fooSet'_casep is transparent
Expands to: Constant SchemeNames.fooSet'_casep
fooSet_cases_nodep : forall P : SProp, P -> P -> fooSet -> P

fooSet_cases_nodep is not universe polymorphic
Arguments fooSet_cases_nodep P%_type_scope f f0 f1
fooSet_cases_nodep is transparent
Expands to: Constant SchemeNames.fooSet_cases_nodep
fooSet_case_nodep : forall P : Prop, P -> P -> fooSet -> P

fooSet_case_nodep is not universe polymorphic
Arguments fooSet_case_nodep P%_type_scope f f0 f1
fooSet_case_nodep is transparent
Expands to: Constant SchemeNames.fooSet_case_nodep
fooSet'_case_nodep : forall P : Set, P -> P -> fooSet' -> P

fooSet'_case_nodep is not universe polymorphic
Arguments fooSet'_case_nodep P%_type_scope f f0 f1
fooSet'_case_nodep is transparent
Expands to: Constant SchemeNames.fooSet'_case_nodep
fooSet'_caset_nodep :
forall P : Type@{fooSet'_caset_nodep.u0}, P -> P -> fooSet' -> P

fooSet'_caset_nodep is not universe polymorphic
Arguments fooSet'_caset_nodep P%_type_scope f f0 f1
fooSet'_caset_nodep is transparent
Expands to: Constant SchemeNames.fooSet'_caset_nodep
fooSet'_casep_nodep@{q | u} :
forall P : Type@{q | u}, P -> P -> fooSet' -> P
(* q | u |=  *)

fooSet'_casep_nodep is universe polymorphic
Arguments fooSet'_casep_nodep P%type_scope f f0 f1
fooSet'_casep_nodep is transparent
Expands to: Constant SchemeNames.fooSet'_casep_nodep
fooSet_beq : fooSet -> fooSet -> bool

fooSet_beq is not universe polymorphic
Arguments fooSet_beq X Y
fooSet_beq is transparent
Expands to: Constant SchemeNames.fooSet_beq
Declared in library SchemeNames, line 177, characters 2-29
fooSet_eq_dec : forall x y : fooSet, {x = y} + {x <> y}

fooSet_eq_dec is not universe polymorphic
Arguments fooSet_eq_dec x y
fooSet_eq_dec is transparent
Expands to: Constant SchemeNames.fooSet_eq_dec
Declared in library SchemeNames, line 177, characters 2-29
internal_fooSet_dec_bl :
forall x : fooSet,
(fun x0 : fooSet => forall y : fooSet, fooSet_beq x0 y = true -> x0 = y) x

internal_fooSet_dec_bl is not universe polymorphic
Arguments internal_fooSet_dec_bl x y _
internal_fooSet_dec_bl is transparent
Expands to: Constant SchemeNames.internal_fooSet_dec_bl
Declared in library SchemeNames, line 177, characters 2-29
internal_fooSet_dec_lb :
forall x : fooSet,
(fun x0 : fooSet => forall y : fooSet, x0 = y -> fooSet_beq x0 y = true) x

internal_fooSet_dec_lb is not universe polymorphic
Arguments internal_fooSet_dec_lb x y _
internal_fooSet_dec_lb is transparent
Expands to: Constant SchemeNames.internal_fooSet_dec_lb
Declared in library SchemeNames, line 177, characters 2-29
fooType_inds :
forall P : fooType -> SProp, P aT -> P bT -> forall f1 : fooType, P f1

fooType_inds is not universe polymorphic
Arguments fooType_inds P%_function_scope f f0 f1
fooType_inds is transparent
Expands to: Constant SchemeNames.fooType_inds
fooType_ind :
forall P : fooType -> Prop, P aT -> P bT -> forall f1 : fooType, P f1

fooType_ind is not universe polymorphic
Arguments fooType_ind P%_function_scope f f0 f1
fooType_ind is transparent
Expands to: Constant SchemeNames.fooType_ind
fooType_rec :
forall P : fooType -> Set, P aT -> P bT -> forall f1 : fooType, P f1

fooType_rec is not universe polymorphic
Arguments fooType_rec P%_function_scope f f0 f1
fooType_rec is transparent
Expands to: Constant SchemeNames.fooType_rec
fooType_rect :
forall P : fooType -> Type@{fooType_rect.u0},
P aT -> P bT -> forall f1 : fooType, P f1

fooType_rect is not universe polymorphic
Arguments fooType_rect P%_function_scope f f0 f1
fooType_rect is transparent
Expands to: Constant SchemeNames.fooType_rect
fooType_elim@{q | u} :
forall P : fooType -> Type@{q | u}, P aT -> P bT -> forall f1 : fooType, P f1
(* q | u |=  *)

fooType_elim is universe polymorphic
Arguments fooType_elim P%function_scope f f0 f1
fooType_elim is transparent
Expands to: Constant SchemeNames.fooType_elim
fooType_inds_nodep : forall P : SProp, P -> P -> fooType -> P

fooType_inds_nodep is not universe polymorphic
Arguments fooType_inds_nodep P%_type_scope f f0 f1
fooType_inds_nodep is transparent
Expands to: Constant SchemeNames.fooType_inds_nodep
fooType_ind_nodep : forall P : Prop, P -> P -> fooType -> P

fooType_ind_nodep is not universe polymorphic
Arguments fooType_ind_nodep P%_type_scope f f0 f1
fooType_ind_nodep is transparent
Expands to: Constant SchemeNames.fooType_ind_nodep
fooType_rec_nodep : forall P : Set, P -> P -> fooType -> P

fooType_rec_nodep is not universe polymorphic
Arguments fooType_rec_nodep P%_type_scope f f0 f1
fooType_rec_nodep is transparent
Expands to: Constant SchemeNames.fooType_rec_nodep
fooType_rect_nodep :
forall P : Type@{fooType_rect_nodep.u0}, P -> P -> fooType -> P

fooType_rect_nodep is not universe polymorphic
Arguments fooType_rect_nodep P%_type_scope f f0 f1
fooType_rect_nodep is transparent
Expands to: Constant SchemeNames.fooType_rect_nodep
fooType_elim_nodep@{q | u} :
forall P : Type@{q | u}, P -> P -> fooType -> P
(* q | u |=  *)

fooType_elim_nodep is universe polymorphic
Arguments fooType_elim_nodep P%type_scope f f0 f1
fooType_elim_nodep is transparent
Expands to: Constant SchemeNames.fooType_elim_nodep
fooType_cases :
forall P : fooType -> SProp, P aT -> P bT -> forall f1 : fooType, P f1

fooType_cases is not universe polymorphic
Arguments fooType_cases P%_function_scope f f0 f1
fooType_cases is transparent
Expands to: Constant SchemeNames.fooType_cases
fooType_case :
forall P : fooType -> Prop, P aT -> P bT -> forall f1 : fooType, P f1

fooType_case is not universe polymorphic
Arguments fooType_case P%_function_scope f f0 f1
fooType_case is transparent
Expands to: Constant SchemeNames.fooType_case
fooType'_case :
forall P : fooType' -> Set, P aT' -> P bT' -> forall f1 : fooType', P f1

fooType'_case is not universe polymorphic
Arguments fooType'_case P%_function_scope f f0 f1
fooType'_case is transparent
Expands to: Constant SchemeNames.fooType'_case
fooType'_caset :
forall P : fooType' -> Type@{fooType'_caset.u0},
P aT' -> P bT' -> forall f1 : fooType', P f1

fooType'_caset is not universe polymorphic
Arguments fooType'_caset P%_function_scope f f0 f1
fooType'_caset is transparent
Expands to: Constant SchemeNames.fooType'_caset
fooType'_casep@{q | u} :
forall P : fooType' -> Type@{q | u},
P aT' -> P bT' -> forall f1 : fooType', P f1
(* q | u |=  *)

fooType'_casep is universe polymorphic
Arguments fooType'_casep P%function_scope f f0 f1
fooType'_casep is transparent
Expands to: Constant SchemeNames.fooType'_casep
fooType_cases_nodep : forall P : SProp, P -> P -> fooType -> P

fooType_cases_nodep is not universe polymorphic
Arguments fooType_cases_nodep P%_type_scope f f0 f1
fooType_cases_nodep is transparent
Expands to: Constant SchemeNames.fooType_cases_nodep
fooType_case_nodep : forall P : Prop, P -> P -> fooType -> P

fooType_case_nodep is not universe polymorphic
Arguments fooType_case_nodep P%_type_scope f f0 f1
fooType_case_nodep is transparent
Expands to: Constant SchemeNames.fooType_case_nodep
fooType'_case_nodep : forall P : Set, P -> P -> fooType' -> P

fooType'_case_nodep is not universe polymorphic
Arguments fooType'_case_nodep P%_type_scope f f0 f1
fooType'_case_nodep is transparent
Expands to: Constant SchemeNames.fooType'_case_nodep
fooType'_caset_nodep :
forall P : Type@{fooType'_caset_nodep.u0}, P -> P -> fooType' -> P

fooType'_caset_nodep is not universe polymorphic
Arguments fooType'_caset_nodep P%_type_scope f f0 f1
fooType'_caset_nodep is transparent
Expands to: Constant SchemeNames.fooType'_caset_nodep
fooType'_casep_nodep@{q | u} :
forall P : Type@{q | u}, P -> P -> fooType' -> P
(* q | u |=  *)

fooType'_casep_nodep is universe polymorphic
Arguments fooType'_casep_nodep P%type_scope f f0 f1
fooType'_casep_nodep is transparent
Expands to: Constant SchemeNames.fooType'_casep_nodep
fooType_beq : fooType -> fooType -> bool

fooType_beq is not universe polymorphic
Arguments fooType_beq X Y
fooType_beq is transparent
Expands to: Constant SchemeNames.fooType_beq
Declared in library SchemeNames, line 251, characters 2-30
fooType_eq_dec : forall x y : fooType, {x = y} + {x <> y}

fooType_eq_dec is not universe polymorphic
Arguments fooType_eq_dec x y
fooType_eq_dec is transparent
Expands to: Constant SchemeNames.fooType_eq_dec
Declared in library SchemeNames, line 251, characters 2-30
internal_fooType_dec_bl :
forall x : fooType,
(fun x0 : fooType => forall y : fooType, fooType_beq x0 y = true -> x0 = y) x

internal_fooType_dec_bl is not universe polymorphic
Arguments internal_fooType_dec_bl x y _
internal_fooType_dec_bl is transparent
Expands to: Constant SchemeNames.internal_fooType_dec_bl
Declared in library SchemeNames, line 251, characters 2-30
internal_fooType_dec_lb :
forall x : fooType,
(fun x0 : fooType => forall y : fooType, x0 = y -> fooType_beq x0 y = true) x

internal_fooType_dec_lb is not universe polymorphic
Arguments internal_fooType_dec_lb x y _
internal_fooType_dec_lb is transparent
Expands to: Constant SchemeNames.internal_fooType_dec_lb
Declared in library SchemeNames, line 251, characters 2-30
File "./output/SchemeNames.v", line 266, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooPoly@{α34 | SchemeNames.96}":
the return type has sort "SProp" while it should be in sort quality α34.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
File "./output/SchemeNames.v", line 267, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooPoly@{α35 | SchemeNames.97}":
the return type has sort "Prop" while it should be in sort quality α35.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
File "./output/SchemeNames.v", line 268, characters 2-45:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooPoly@{α36 | SchemeNames.98}":
the return type has sort "Set" while it should be in sort quality α36.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
File "./output/SchemeNames.v", line 269, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type "fooPoly@{α37 | SchemeNames.99}":
the return type has sort "Type@{SchemeNames.100}"
while it should be in sort quality α37.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
fooPoly_elim@{α | u u0} :
forall P : fooPoly@{α | u} -> Type@{α | u0},
P aPo@{α | u} -> P bPo@{α | u} -> forall f1 : fooPoly@{α | u}, P f1
(* α | u u0 |=  *)

fooPoly_elim is universe polymorphic
Arguments fooPoly_elim P%function_scope f f0 f1
fooPoly_elim is transparent
Expands to: Constant SchemeNames.fooPoly_elim
File "./output/SchemeNames.v", line 276, characters 2-48:
The command has indeed failed with message:
Incorrect elimination in the inductive type
"fooPoly@{α39 | SchemeNames.103}":
the return type has sort "SProp" while it should be in sort quality α39.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
File "./output/SchemeNames.v", line 277, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type
"fooPoly@{α40 | SchemeNames.104}":
the return type has sort "Prop" while it should be in sort quality α40.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
File "./output/SchemeNames.v", line 278, characters 2-46:
The command has indeed failed with message:
Incorrect elimination in the inductive type
"fooPoly@{α41 | SchemeNames.105}":
the return type has sort "Set" while it should be in sort quality α41.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
File "./output/SchemeNames.v", line 279, characters 2-47:
The command has indeed failed with message:
Incorrect elimination in the inductive type
"fooPoly@{α42 | SchemeNames.106}":
the return type has sort "Type@{SchemeNames.107}"
while it should be in sort quality α42.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
fooPoly_elim_nodep@{α | u u0} :
forall P : Type@{α | u0}, P -> P -> fooPoly@{α | u} -> P
(* α | u u0 |=  *)

fooPoly_elim_nodep is universe polymorphic
Arguments fooPoly_elim_nodep P%type_scope f f0 f1
fooPoly_elim_nodep is transparent
Expands to: Constant SchemeNames.fooPoly_elim_nodep
File "./output/SchemeNames.v", line 292, characters 2-48:
The command has indeed failed with message:
Incorrect elimination of "f1" in the inductive type
"fooPoly@{α48 | SchemeNames.114}":
the return type has sort "Prop" while it should be in sort quality α48.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
fooPoly_cases@{u} :
forall P : fooPoly@{SProp | u} -> SProp,
P aPo@{SProp | u} ->
P bPo@{SProp | u} -> forall f1 : fooPoly@{SProp | u}, P f1
(* u |=  *)

fooPoly_cases is universe polymorphic
Arguments fooPoly_cases P%function_scope f f0 f1
fooPoly_cases is transparent
Expands to: Constant SchemeNames.fooPoly_cases
fooPoly_case not a defined object.
fooPoly'_case@{u} :
forall P : fooPoly'@{Type | u} -> Set,
P aPo'@{Type | u} ->
P bPo'@{Type | u} -> forall f1 : fooPoly'@{Type | u}, P f1
(* u |=  *)

fooPoly'_case is universe polymorphic
Arguments fooPoly'_case P%function_scope f f0 f1
fooPoly'_case is transparent
Expands to: Constant SchemeNames.fooPoly'_case
fooPoly'_caset@{u u0} :
forall P : fooPoly'@{Type | u} -> Type@{u0},
P aPo'@{Type | u} ->
P bPo'@{Type | u} -> forall f1 : fooPoly'@{Type | u}, P f1
(* u u0 |=  *)

fooPoly'_caset is universe polymorphic
Arguments fooPoly'_caset P%function_scope f f0 f1
fooPoly'_caset is transparent
Expands to: Constant SchemeNames.fooPoly'_caset
fooPoly'_casep@{α | u u0} :
forall P : fooPoly'@{α | u} -> Type@{α | u0},
P aPo'@{α | u} -> P bPo'@{α | u} -> forall f1 : fooPoly'@{α | u}, P f1
(* α | u u0 |=  *)

fooPoly'_casep is universe polymorphic
Arguments fooPoly'_casep P%function_scope f f0 f1
fooPoly'_casep is transparent
Expands to: Constant SchemeNames.fooPoly'_casep
File "./output/SchemeNames.v", line 306, characters 2-41:
The command has indeed failed with message:
Incorrect elimination of "f1" in the inductive type
"fooPoly@{α53 | SchemeNames.121}":
the return type has sort "Prop" while it should be in sort quality α53.
Elimination of a sort polymorphic inductive object instantiated to a variable sort quality
is only allowed on a predicate in the same sort quality.
fooPoly_cases_nodep@{u} :
forall P : SProp, P -> P -> fooPoly@{SProp | u} -> P
(* u |=  *)

fooPoly_cases_nodep is universe polymorphic
Arguments fooPoly_cases_nodep P%type_scope f f0 f1
fooPoly_cases_nodep is transparent
Expands to: Constant SchemeNames.fooPoly_cases_nodep
fooPoly_case_nodep not a defined object.
fooPoly'_case_nodep@{u} :
forall P : Set, P -> P -> fooPoly'@{Type | u} -> P
(* u |=  *)

fooPoly'_case_nodep is universe polymorphic
Arguments fooPoly'_case_nodep P%type_scope f f0 f1
fooPoly'_case_nodep is transparent
Expands to: Constant SchemeNames.fooPoly'_case_nodep
fooPoly'_caset_nodep@{u u0} :
forall P : Type@{u0}, P -> P -> fooPoly'@{Type | u} -> P
(* u u0 |=  *)

fooPoly'_caset_nodep is universe polymorphic
Arguments fooPoly'_caset_nodep P%type_scope f f0 f1
fooPoly'_caset_nodep is transparent
Expands to: Constant SchemeNames.fooPoly'_caset_nodep
fooPoly'_casep_nodep@{α | u u0} :
forall P : Type@{α | u0}, P -> P -> fooPoly'@{α | u} -> P
(* α | u u0 |=  *)

fooPoly'_casep_nodep is universe polymorphic
Arguments fooPoly'_casep_nodep P%type_scope f f0 f1
fooPoly'_casep_nodep is transparent
Expands to: Constant SchemeNames.fooPoly'_casep_nodep
File "./output/SchemeNames.v", line 319, characters 2-35:
The command has indeed failed with message:
Cannot extract computational content from proposition 
"fooPoly".
F_rect :
forall (f : Type@{F.u0}) (P : F f -> Type@{F_rect.u0}),
(forall f0 : f, P (C f f0)) -> forall f1 : F f, P f1

F_rect is not universe polymorphic
Arguments F_rect f%_type_scope (P f0)%_function_scope f1
F_rect is transparent
Expands to: Constant SchemeNames.F_rect
Declared in library SchemeNames, line 324, characters 0-30
PP_rect :
forall (P : Type@{PP.u0}) (P0 : PP P -> Type@{PP_rect.u0}),
(forall p : P, P0 (D P p)) -> forall p : PP P, P0 p

PP_rect is not universe polymorphic
Arguments PP_rect P%_type_scope (P0 f)%_function_scope p
PP_rect is transparent
Expands to: Constant SchemeNames.PP_rect
Declared in library SchemeNames, line 327, characters 0-32
