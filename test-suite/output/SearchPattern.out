false: bool
true: bool
negb: bool -> bool
xorb: bool -> bool -> bool
andb: bool -> bool -> bool
orb: bool -> bool -> bool
implb: bool -> bool -> bool
Nat.odd: nat -> bool
Nat.even: nat -> bool
Numeral.uint_beq: Numeral.uint -> Numeral.uint -> bool
Nat.testbit: nat -> nat -> bool
Nat.eqb: nat -> nat -> bool
Hexadecimal.hexadecimal_beq:
  Hexadecimal.hexadecimal -> Hexadecimal.hexadecimal -> bool
Nat.ltb: nat -> nat -> bool
Nat.leb: nat -> nat -> bool
Numeral.numeral_beq: Numeral.numeral -> Numeral.numeral -> bool
Numeral.int_beq: Numeral.int -> Numeral.int -> bool
Hexadecimal.int_beq: Hexadecimal.int -> Hexadecimal.int -> bool
Hexadecimal.uint_beq: Hexadecimal.uint -> Hexadecimal.uint -> bool
Decimal.decimal_beq: Decimal.decimal -> Decimal.decimal -> bool
Decimal.int_beq: Decimal.int -> Decimal.int -> bool
Decimal.uint_beq: Decimal.uint -> Decimal.uint -> bool
Nat.two: nat
Nat.zero: nat
Nat.one: nat
O: nat
Nat.double: nat -> nat
Nat.sqrt: nat -> nat
Nat.div2: nat -> nat
Nat.log2: nat -> nat
Nat.pred: nat -> nat
Nat.square: nat -> nat
S: nat -> nat
Nat.succ: nat -> nat
Nat.ldiff: nat -> nat -> nat
Nat.add: nat -> nat -> nat
Nat.land: nat -> nat -> nat
Nat.lxor: nat -> nat -> nat
Nat.sub: nat -> nat -> nat
Nat.mul: nat -> nat -> nat
Nat.tail_mul: nat -> nat -> nat
Nat.max: nat -> nat -> nat
Nat.tail_add: nat -> nat -> nat
Nat.pow: nat -> nat -> nat
Nat.min: nat -> nat -> nat
Nat.modulo: nat -> nat -> nat
Nat.div: nat -> nat -> nat
Nat.lor: nat -> nat -> nat
Nat.gcd: nat -> nat -> nat
Hexadecimal.nb_digits: Hexadecimal.uint -> nat
Nat.of_hex_uint: Hexadecimal.uint -> nat
Nat.of_num_uint: Numeral.uint -> nat
Nat.of_uint: Decimal.uint -> nat
Decimal.nb_digits: Decimal.uint -> nat
Nat.tail_addmul: nat -> nat -> nat -> nat
Nat.of_hex_uint_acc: Hexadecimal.uint -> nat -> nat
Nat.of_uint_acc: Decimal.uint -> nat -> nat
Nat.sqrt_iter: nat -> nat -> nat -> nat -> nat
Nat.log2_iter: nat -> nat -> nat -> nat -> nat
length: forall [A : Type], list A -> nat
Nat.bitwise: (bool -> bool -> bool) -> nat -> nat -> nat -> nat
Nat.div2: nat -> nat
Nat.sqrt: nat -> nat
Nat.log2: nat -> nat
Nat.double: nat -> nat
S: nat -> nat
Nat.square: nat -> nat
Nat.succ: nat -> nat
Nat.pred: nat -> nat
Nat.land: nat -> nat -> nat
Nat.max: nat -> nat -> nat
Nat.gcd: nat -> nat -> nat
Nat.modulo: nat -> nat -> nat
Nat.ldiff: nat -> nat -> nat
Nat.tail_add: nat -> nat -> nat
Nat.pow: nat -> nat -> nat
Nat.lxor: nat -> nat -> nat
Nat.div: nat -> nat -> nat
Nat.lor: nat -> nat -> nat
Nat.mul: nat -> nat -> nat
Nat.min: nat -> nat -> nat
Nat.add: nat -> nat -> nat
Nat.sub: nat -> nat -> nat
Nat.tail_mul: nat -> nat -> nat
Nat.tail_addmul: nat -> nat -> nat -> nat
Nat.of_uint_acc: Decimal.uint -> nat -> nat
Nat.of_hex_uint_acc: Hexadecimal.uint -> nat -> nat
Nat.sqrt_iter: nat -> nat -> nat -> nat -> nat
Nat.log2_iter: nat -> nat -> nat -> nat -> nat
Nat.bitwise: (bool -> bool -> bool) -> nat -> nat -> nat -> nat
mult_n_Sm: forall n m : nat, n * m + n = n * S m
iff_refl: forall A : Prop, A <-> A
le_n: forall n : nat, n <= n
identity_refl: forall [A : Type] (a : A), identity a a
eq_refl: forall {A : Type} {x : A}, x = x
Nat.divmod: nat -> nat -> nat -> nat -> nat * nat
(use "About" for full details on the implicit arguments of eq_refl)
conj: forall [A B : Prop], A -> B -> A /\ B
pair: forall {A B : Type}, A -> B -> A * B
Nat.divmod: nat -> nat -> nat -> nat -> nat * nat
h: n <> newdef n
h: n <> newdef n
h: P n
h': ~ P n
h: P n
h: P n
