[< 0 > + < 1 > * < 2 >]
     : nat
[< b > + < b > * < 2 >]
     : nat
[<< # 0 >>]
     : option nat
[1 {f 1}]
     : Expr
fun (x : nat) (y z : Expr) => [1 + y z + {f x}]
     : nat -> Expr -> Expr -> Expr
fun e : Expr =>
match e with
| [x y + z] => [x + y z]
| [1 + 1] => [1]
| _ => [e + e]
end
     : Expr -> Expr
[(1 + 1)]
     : Expr
Let "x" e1 e2
     : expr
Let "x" e1 e2
     : expr
fun x : nat => (# x)%nat
     : nat -> nat
fun x : nat => ## x
     : nat -> nat
fun x : nat => # x
     : nat -> nat
fun x : nat => ### x
     : nat -> nat
fun x : nat => ## x
     : nat -> nat
fun x : nat => (x.-1)%pred
     : nat -> nat
∀ a : nat, a = 0
     : Prop
((∀ a : nat, a = 0) -> True)%type
     : Prop
#
     : Prop
# -> True
     : Prop
((∀ a : nat, a = 0) -> True)%type
     : Prop
##
     : Prop
forall x : nat, x.+1 = x.+1
     : Prop
Notation Cn := Foo.FooCn
Expands to: Notation Top.J.Mfoo.Foo.Bar.Cn
(add.s z) y
     : nat
(add.s z).s z
     : nat
(add x).s z
     : nat
add2 z z
     : nat
gxy.s z
     : nat
fun (x : forall (x : ?T) (x0 : ?T0), ?T1) (y : forall x0 : ?T, ?T0@{x:=x0})
  (z : ?T) => app (app x z) (app y z)
     : (forall (x : ?T) (x0 : ?T0), ?T1) ->
       forall (y : forall x0 : ?T, ?T0@{x:=x0}) (z : ?T),
       ?T1@{x:=z; x0:=app y z}
where
?T : [ |- Type]
?T0 : [x : ?T |- Type]
?T1 : [x : ?T  x0 : ?T0 |- Type]
fun (f : X -> nat) (x y : X) (z t : nat) => f (x + y) = (z + t)%nat
     : (X -> nat) -> X -> X -> nat -> nat -> Prop
