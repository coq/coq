(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *         Copyright INRIA, CNRS and contributors             *)
(* <O___,, * (see version control and CREDITS file for authors & dates) *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

{

open Constrexpr
open Vernacexpr
open Hints

module C = Constr

open Pcoq
open Pcoq.Prim
open Pcoq.Constr
open Pvernac.Vernac_

let thm_token = G_vernac.thm_token

let hint = Entry.create "hint"

let warn_deprecated_focus =
  CWarnings.create ~name:"deprecated-focus" ~category:"deprecated"
         (fun () ->
           Pp.strbrk
             "The Focus command is deprecated; use bullets or focusing brackets instead"
         )

let warn_deprecated_focus_n n =
  CWarnings.create ~name:"deprecated-focus" ~category:"deprecated"
         (fun () ->
           Pp.(str "The Focus command is deprecated;" ++ spc ()
               ++ str "use '" ++ int n ++ str ": {' instead")
         )

let warn_deprecated_unfocus =
  CWarnings.create ~name:"deprecated-unfocus" ~category:"deprecated"
         (fun () -> Pp.strbrk "The Unfocus command is deprecated")

}

(* Proof commands *)
GRAMMAR EXTEND Gram
  GLOBAL: hint command;

  opt_hintbases:
  [ [ -> { [] }
    | ":"; l = LIST1 [id = IDENT -> { id } ] -> { l } ] ]
  ;
  command: TOP
    [ [ IDENT "Goal"; c = lconstr ->
        { VernacPure (VernacDefinition (Decls.(NoDischarge, Definition), ((CAst.make ~loc Names.Anonymous), None), ProveBody ([], c))) }
      | IDENT "Proof" -> { VernacPure (VernacProof (None,None)) }
      | IDENT "Proof"; IDENT "using"; l = G_vernac.section_subset_expr ->
          { VernacPure (VernacProof (None,Some l)) }
      | IDENT "Proof" ; IDENT "Mode" ; mn = string -> { VernacSynterp (VernacProofMode mn) }
      | IDENT "Proof"; c = lconstr -> { VernacPure (VernacExactProof c) }
      | IDENT "Abort" -> { VernacPure VernacAbort }
      | IDENT "Abort"; IDENT "All" -> { VernacPure VernacAbortAll }
      | IDENT "Admitted" -> { VernacPure (VernacEndProof Admitted) }
      | IDENT "Qed" -> { VernacPure (VernacEndProof (Proved (Opaque,None))) }
      | IDENT "Save"; id = identref ->
          { VernacPure (VernacEndProof (Proved (Opaque, Some id))) }
      | IDENT "Defined" -> { VernacPure (VernacEndProof (Proved (Transparent,None))) }
      |	IDENT "Defined"; id=identref ->
          { VernacPure (VernacEndProof (Proved (Transparent,Some id))) }
      | IDENT "Restart" -> { VernacPure VernacRestart }
      | IDENT "Undo" -> { VernacPure (VernacUndo 1) }
      | IDENT "Undo"; n = natural -> { VernacPure (VernacUndo n) }
      | IDENT "Undo"; IDENT "To"; n = natural -> { VernacPure (VernacUndoTo n) }
      | IDENT "Focus" ->
         { warn_deprecated_focus ~loc ();
         VernacPure (VernacFocus None) }
      | IDENT "Focus"; n = natural ->
         { warn_deprecated_focus_n n ~loc ();
         VernacPure (VernacFocus (Some n)) }
      | IDENT "Unfocus" ->
         { warn_deprecated_unfocus ~loc ();
         VernacPure VernacUnfocus }
      | IDENT "Unfocused" -> { VernacPure VernacUnfocused }
      | IDENT "Show" -> { VernacPure (VernacShow (ShowGoal OpenSubgoals)) }
      | IDENT "Show"; n = natural -> { VernacPure (VernacShow (ShowGoal (NthGoal n))) }
      | IDENT "Show"; id = ident -> { VernacPure (VernacShow (ShowGoal (GoalId id))) }
      | IDENT "Show"; IDENT "Existentials" -> { VernacPure (VernacShow ShowExistentials) }
      | IDENT "Show"; IDENT "Universes" -> { VernacPure (VernacShow ShowUniverses) }
      | IDENT "Show"; IDENT "Conjectures" -> { VernacPure (VernacShow ShowProofNames) }
      | IDENT "Show"; IDENT "Proof" -> { VernacPure (VernacShow ShowProof) }
      | IDENT "Show"; IDENT "Intro" -> { VernacPure (VernacShow (ShowIntros false)) }
      | IDENT "Show"; IDENT "Intros" -> { VernacPure (VernacShow (ShowIntros true)) }
      | IDENT "Show"; IDENT "Match"; id = reference -> { VernacPure (VernacShow (ShowMatch id)) }
      | IDENT "Guarded" -> { VernacPure VernacCheckGuard }
      (* Hints for Auto and EAuto *)
      | IDENT "Create"; IDENT "HintDb" ;
          id = IDENT ; b = [ IDENT "discriminated" -> { true } | -> { false } ] ->
            { VernacPure (VernacCreateHintDb (id, b)) }
      | IDENT "Remove"; IDENT "Hints"; ids = LIST1 global; dbnames = opt_hintbases ->
          { VernacPure (VernacRemoveHints (dbnames, ids)) }
      | IDENT "Hint"; h = hint; dbnames = opt_hintbases ->
          { VernacPure (VernacHints (dbnames, h)) }
      ] ];
  reference_or_constr:
   [ [ r = global -> { HintsReference r }
     | c = constr -> { HintsConstr c } ] ]
  ;
  hint:
    [ [ IDENT "Resolve"; lc = LIST1 reference_or_constr; info = hint_info ->
          { HintsResolve (List.map (fun x -> (info, true, x)) lc) }
      | IDENT "Resolve"; "->"; lc = LIST1 global; n = OPT natural ->
          { HintsResolveIFF (true, lc, n) }
      | IDENT "Resolve"; "<-"; lc = LIST1 global; n = OPT natural ->
          { HintsResolveIFF (false, lc, n) }
      | IDENT "Immediate"; lc = LIST1 reference_or_constr -> { HintsImmediate lc }
      | IDENT "Variables"; IDENT "Transparent" -> { HintsTransparency (HintsVariables, true) }
      | IDENT "Variables"; IDENT "Opaque" -> { HintsTransparency (HintsVariables, false) }
      | IDENT "Constants"; IDENT "Transparent" -> { HintsTransparency (HintsConstants, true) }
      | IDENT "Constants"; IDENT "Opaque" -> { HintsTransparency (HintsConstants, false) }
      | IDENT "Transparent"; lc = LIST1 global -> { HintsTransparency (HintsReferences lc, true) }
      | IDENT "Opaque"; lc = LIST1 global -> { HintsTransparency (HintsReferences lc, false) }
      | IDENT "Mode"; l = global; m = mode -> { HintsMode (l, m) }
      | IDENT "Unfold"; lqid = LIST1 global -> { HintsUnfold lqid }
      | IDENT "Constructors"; lc = LIST1 global -> { HintsConstructors lc } ] ]
    ;
  constr_body:
    [ [ ":="; c = lconstr -> { c }
      | ":"; t = lconstr; ":="; c = lconstr -> { CAst.make ~loc @@ CCast(c,C.DEFAULTcast, t) } ] ]
  ;
  mode:
    [ [ l = LIST1 [ "+" -> { ModeInput }
                  | "!" -> { ModeNoHeadEvar }
                  | "-" -> { ModeOutput } ] -> { l } ] ]
  ;
END
