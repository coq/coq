
Status of Extraction in Coq version 7.x
======================================

J.C. Filliâtre
P. Letouzey



Extraction code has been completely rewritten since version V6.3. 
This work is still not finished, but most parts of it are already usable. 
In consequence it is included in the Coq V7.0 final release. 
But don't be mistaken: 

	THIS WORK IS STILL EXPERIMENTAL !

1) Principles 

The main goal of the new extraction is to handle any Coq term, even 
those upon sort Type, and to produce code that always compiles. 
Thus it will never answer something like "Not an ML type", but rather
a dummy term like the ML unit. 

Translation between Coq and ML is based upon the following principles: 

- Terms of sort Prop don't have any computational meaning, so they are
merged in one ML term "prop", which is for the moment the ML constant ().
This part is done according to P. Letouzey's work (*).

- Terms that are arities (i.e. something of shape ( : )( : )...s with 
s a sort ) don't have any ML counterpart, since they are types of 
types transformers. We have also a special constant "arity" to 
represent them if needed.

- A Coq term gives a ML term or a ML type depending of its type: 
a term of type an arity will give a ML type, and otherwise a ML term.

And the rest of the translation is (almost) straightforward: an inductive
gives an inductive, etc...

This gives ML code that have no special reason to typecheck, due 
to the incompatibilities between Coq and ML typing systems. In fact
most of the time everything goes right. For example, it is sufficient 
to extract and compile everything in the "theories" directory 
(cf test subdirectory).
The last feature (not yet implemented) is to ensure that the extracted
code will typecheck. This will be done soon by adding some "Obj.magic"
calls in the code. 

2) Differences with previous extraction (V6.3 and before)

2.a) The pros 

The ability to extract every Coq term, as explain in the previous 
paragraph. 

The ability to extract from a file an ML module (cf Extraction Module in the 
documentation)

You can have a taste of extraction directly at the toplevel by 
using the "Extraction <ident>" or the "Recursive Extraction <ident>".
This toplevel extraction was already there in V6.3, but was printing 
Fw terms. It now prints in the language of your choice: 
Ocaml, Haskell or an Ocaml-like with Coq namings. 

The optimization done on extracted code has been ported between 
V6.3 and V7 and enhanced, and in particular the mechanism of automatic
expansion. 

2.b) The cons 

The presence of some parasite "unit" or "prop" (now () in ocaml and __ in 
Haskell) as dummy arguments
in functions. This denotes the rests of a proof part. The previous 
extraction was able to remove them totally, but this is no more possible
due to extraction upon Type.
For example, let's take this pathological term: 
	(if b then Set else Prop)  : Type
The only way to know if this is an Set (to keep) or a Prop (to remove) 
is to compute the boolean b, and we do not want to do that during 
extraction. 

There is no more "ML import" feature. You can compensate by using 
Axioms, and then "Extract Constant ..." 

Still no assurance of typechecking, since there is still no "Obj.magic"
yet. Coming soon ...

3) Examples 

The file "test-extraction.v" is made of some examples used while debugging.

In the subdirectory "test", you can test extraction on the Coq theories.
Go there.
"make tree" to make a local copy of the "theories" tree
"make" to extract & compile most of the theories file 

See also Reference Manual for explanation of extraction syntaxes
and more examples. 


(*):
Exécution de termes de preuves: une nouvelle méthode d'extraction 
pour le Calcul des Constructions Inductives, Pierre Letouzey,
DEA thesis, 2000, 
http://www.eleves.ens.fr/home/letouzey/download/rapport_dea.ps.gz




Any feedback is welcome: 
Pierre.Letouzey@lri.fr
Jean.Christophe.Filliatre@lri.fr
coq@pauillac.inria.fr
