let prooftreedtdname = "http://localhost:8081/getdtd?url=prooftree.dtd";;

let std_ppcmds_to_string s =
   Pp.msg_with Format.str_formatter s;
   Format.flush_str_formatter ()
;;


(* Transform a constr to an Xml.token Stream.t *)
(* env is a named context                      *)
(*CSC: in verita' dovrei "separare" le variabili vere e lasciarle come Var! *)
let constr_to_xml obj sigma env =
  let ids_to_terms = Hashtbl.create 503 in
  let constr_to_ids = Acic.CicHash.create 503 in
  let ids_to_father_ids = Hashtbl.create 503 in
  let ids_to_inner_sorts = Hashtbl.create 503 in
  let ids_to_inner_types = Hashtbl.create 503 in

  let pvars = [] in
  let named_context = Environ.named_context env  in
  let rel_context = Sign.push_named_to_rel_context named_context [] in
  let rel_env =
   Environ.push_rel_context rel_context (Environ.reset_context env) in
  let obj' =
   Term.subst_vars (List.map (function (i,_,_) -> i) named_context) obj in
  let seed = ref 0 in
   try
    let annobj =
     Cic2acic.acic_of_cic_context' false seed ids_to_terms constr_to_ids
      ids_to_father_ids ids_to_inner_sorts ids_to_inner_types pvars rel_env
      sigma (Term.unshare obj') None
    in
     Acic2Xml.print_term ids_to_inner_sorts annobj
   with e ->
    begin
     Pp.ppnl (Pp.str "Problem during the conversion of constr into XML") ;
Pp.ppnl (Pp.str "ENVIRONMENT:") ;
Pp.ppnl (Printer.pr_context_of rel_env) ;
Pp.ppnl (Pp.str "TERM:") ;
Pp.ppnl (Printer.prterm_env rel_env obj') ;
Pp.ppnl (Pp.str "RAW-TERM:") ;
Pp.ppnl (Printer.prterm obj') ;
     Xml.xml_empty "MISSING TERM" [] (*; raise e*)
    end
;;

let first_word s =
   try let i = String.index s ' ' in
       String.sub s 0 i
   with _ -> s
;;

let string_of_prim_rule x = match x with
  | Proof_type.Intro _-> "Intro"
  | Proof_type.Intro_replacing _-> "Intro_replacing"
  | Proof_type.Cut (_,_,_) -> "Cut"
  | Proof_type.FixRule (_,_,_) -> "FixRule"
  | Proof_type.Cofix (_,_)-> "Cofix"
  | Proof_type.Refine _ -> "Refine"
  | Proof_type.Convert_concl _ -> "Convert_concl"
  | Proof_type.Convert_hyp _->"Convert_hyp"
  | Proof_type.Thin _ -> "Thin"
  | Proof_type.ThinBody _-> "ThinBody"
  | Proof_type.Move (_,_,_) -> "Move"
  | Proof_type.Rename (_,_) -> "Rename"


let
 print_proof_tree curi pf proof_tree_to_constr
  proof_tree_to_flattened_proof_tree constr_to_ids
=
 let module PT = Proof_type in
 let module L = Logic in
 let module X = Xml in
  let ids_of_node node =
   let constr = Proof2aproof.ProofTreeHash.find proof_tree_to_constr node in
(*
let constr =
 try
    Proof2aproof.ProofTreeHash.find proof_tree_to_constr node
 with _ -> Pp.ppnl (Pp.(++) (Pp.str "Node of the proof-tree that generated
no lambda-term: ") (Refiner.print_script true (Evd.empty)
(Global.named_context ()) node)) ; assert false (* Closed bug, should not
happen any more *)
in
*)
   try
    Some (Acic.CicHash.find constr_to_ids constr)
   with _ ->
Pp.ppnl (Pp.(++) (Pp.str
"The_generated_term_is_not_a_subterm_of_the_final_lambda_term")
(Printer.prterm constr)) ;
    None
  in
  let rec aux node old_hyps forget=
   let of_attribute =
    match ids_of_node node with
       None -> []
     | Some id -> ["of",id]
   in
    match node with
       {PT.ref=Some(PT.Prim tactic_expr,nodes)} ->
         let tac = string_of_prim_rule tactic_expr in
         let of_attribute = ("name",tac)::of_attribute in
          X.xml_nempty "Prim" of_attribute
           (List.fold_left
             (fun i n -> [< i ; (aux n old_hyps false) >]) [<>] nodes)

     | {PT.goal=goal;
        PT.ref=Some(PT.Tactic (tactic_expr,hidden_proof),nodes)} ->
         (* [hidden_proof] is the proof of the tactic;                     *)
         (* [nodes] are the proof of the subgoals generated by the tactic; *)
         (* [flat_proof] if the proof-tree obtained substituting [nodes]   *)
         (*  for the holes in [hidden_proof]                               *)
        let sgl,v = Refiner.frontier hidden_proof in
        let flat_proof =
         Proof2aproof.ProofTreeHash.find proof_tree_to_flattened_proof_tree node
        in

        if forget then aux flat_proof old_hyps false else
        begin
         (****** la tactique employee *)
         let tac = std_ppcmds_to_string (Pptactic.pr_tactic tactic_expr) in
         let tacname= first_word tac in
         let of_attribute = ("name",tacname)::("script",tac)::of_attribute in

         (****** le but *)
         let {Evd.evar_concl=concl;
              Evd.evar_hyps=hyps}=goal in

         let rc = (Proof_trees.rc_of_gc Evd.empty goal) in
         let sigma = Proof_trees.get_gc rc in
         let hyps = Proof_trees.get_hyps rc in
         let env= Proof_trees.get_env rc in

         let xgoal = X.xml_nempty "Goal" [] (constr_to_xml concl sigma env) in

         let rec build_hyps =
          function
           | [] -> xgoal
           | (id,c,tid)::hyps1 ->
              [< build_hyps hyps1;
                 (X.xml_nempty "Hypothesis" ["name",(Names.string_of_id id)]
                   (constr_to_xml tid sigma env))
              >] in
         let old_names = List.map (fun (id,c,tid)->id) old_hyps in
         let new_hyps =
          List.filter (fun (id,c,tid)-> not (List.mem id old_names)) hyps in

         X.xml_nempty "Tactic" of_attribute
          [<(build_hyps new_hyps) ; (aux flat_proof hyps true)>]
        end

     | {PT.ref=Some(PT.Change_evars,nodes)} ->
         X.xml_nempty "Change_evars" of_attribute
          (List.fold_left
            (fun i n -> [< i ; (aux n old_hyps false) >]) [<>] nodes)

     | {PT.ref=None;PT.goal=goal} ->
         X.xml_empty "Open_goal" of_attribute
  in
   [< X.xml_cdata "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n" ;
      X.xml_cdata ("<!DOCTYPE ProofTree SYSTEM \""^prooftreedtdname ^"\">\n\n");
      X.xml_nempty "ProofTree" ["of",curi] (aux pf [] false)
   >]
;;
