let prooftreedtdname = "http://localhost:8081/getdtd?url=prooftree.dtd";;

let print_proof_tree curi pf proof_tree_to_constr constr_to_ids =
 let module PT = Proof_type in
 let module L = Logic in
 let module X = Xml in
  let ids_of_node node =
   let constr = Hashtbl.find proof_tree_to_constr node in
(*
 try
    Hashtbl.find proof_tree_to_constr node
 with _ -> Pp.ppnl (Pp.(++) (Pp.str "Node of the proof-tree that generated no lambda-term: ") (Refiner.print_script true (Evd.empty) (Global.named_context ()) node)) ; assert false (* Closed bug, should not happen any more *)
*)
   try
    Some (Acic.CicHash.find constr_to_ids constr)
   with _ ->
Pp.ppnl (Pp.(++) (Pp.str "The_generated_term_is_not_a_subterm_of_the_final_lambda_term") (Printer.prterm constr)) ; 
    None
  in
  let rec aux node =
   let of_attribute =
    match ids_of_node node with
       None -> []
     | Some id -> ["of",id]
   in
    match node with
       {PT.ref=Some(PT.Prim _,nodes)} ->
         X.xml_nempty "Prim" of_attribute
          [< (List.fold_left (fun i n -> [< i ; (aux n) >]) [<>] nodes) >]
	  
     | {PT.ref=Some(PT.Tactic (_,hidden_proof),nodes)} ->
         (* [hidden_proof] is the proof of the tactic;                     *)
         (* [nodes] are the proof of the subgoals generated by the tactic; *)
         (* [flat_proof] if the proof-tree obtained substituting [nodes]   *)
         (*  for the holes in [hidden_proof]                               *)
	 let sgl,v = Refiner.frontier hidden_proof in
	 let flat_proof = v nodes in
(*
Pp.ppnl (Pp.(++) (Pp.str "Node: ") (Refiner.print_script true (Evd.empty) (Global.named_context ()) node)) ;
Pp.ppnl (Pp.(++) (Pp.str "Hidden: ") (Refiner.print_script true (Evd.empty) (Global.named_context ()) hidden_proof)) ;
Pp.ppnl (Pp.(++) (Pp.str "Flat: ") (Refiner.print_script true (Evd.empty) (Global.named_context ()) flat_proof)) ;
*)
          X.xml_nempty "Tactic" of_attribute (aux flat_proof)
	  
     | {PT.ref=Some(PT.Change_evars,nodes)} ->
         X.xml_nempty "Change_evars" of_attribute
          [< (List.fold_left (fun i n -> [< i ; (aux n) >]) [<>] nodes) >]
	  
     | {PT.ref=None;PT.goal=goal} ->
         X.xml_empty "Open_goal" of_attribute
   in
    [< X.xml_cdata "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n" ;
       X.xml_cdata ("<!DOCTYPE ProofTree SYSTEM \"" ^ prooftreedtdname ^"\">\n\n");
       X.xml_nempty "ProofTree" ["of",curi] (aux pf)
    >]
;;
